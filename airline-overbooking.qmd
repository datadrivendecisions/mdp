---
title: Airline overbooking
jupyter: python3
---


## Homework Assigmment 1.6 p.11 from Lecture notes

An airline seeks a reservation policy for a flight with $S$ seats that maximizes its expected profit from the flight. Reservation requests arrive hourly according to a Bernoulli process with $p$ being the probability of a reservation request per hour (at most one reservation request will arrive per hour). A passenger with a booked reservation pays the fare $f > 0$ at flight time. If $b \geq 0$ passengers with booked reservations are denied boarding at flight time, they do not pay the fare, and the airline pays them a penalty $c(b)$ (divided among them) where $b \mapsto c(b)$ is increasing with $c(0) = 0$.

Consider the $n$-th hour before flight time $T$. At the beginning of the hour, the airline reviews the number of booked reservations on hand, $r$ say, and decides whether to book (accept) or decline a reservation request arriving during the next hour. Each of the $r$ booked reservations may cancel during the hour, independently of each other, with probability $q$.

For this reason, the airline is considering the possibility of overbooking the flight to compensate for cancellations. Let $V^*_n(r)$ be the maximum expected future profit when there are $r$ booked reservations at the beginning of the hour, before the accept/decline decision has been taken, and reservation requests and cancellations during the hour have occurred. Let $W^*_n(r)$ be the maximum expected future profit when there are $r$ booked reservations after booking or declining a reservation request, but before cancellations. The aim is to determine an optimal reservation policy for any value of the number of booked reservations at the beginning of each hour till the flight time $T$.

### a) Markov Decision Model

Formulate the problem as a Markov decision model, by determining the state space, action spaces, rewards, terminal rewards, and the transition probabilities. Formulate the optimality equation from which an optimal reservation policy can be determined.

### b) Optimality of Booking-Limit Policies

Assume, as can be shown, that if $g$ is a quasiconcave function on the integers, then $r \mapsto \mathbb{E}(g(B_r))$ is quasiconcave, where $B_r$ is a sum of independent identically distributed Bernoulli random variables. We recall that $g$ is quasiconcave on the (positive) integers when there exists a number $a$ such that $g$ is increasing on $[0, a]$ and decreasing on $[a, \infty]$.

Use this result to show the following facts. First, show that $r \mapsto W^*_n(r)$ is quasiconcave.

Let $b_n = \arg\max_r W^*_n(r)$. Call $b_n$ the booking limit. Then show that $r \mapsto V^*_n(r)$ is quasiconcave with maximum $b_n$. Finally, show that it is optimal to accept a reservation if and only if $r < b_n$, with $r$ the number of booked reservations on hand at the beginning of the hour (before a decision has been taken).

### c) Solving the Problem

Solve the problem when the parameters are as follows:

-   $T = 30$
-   $c(b) = f \cdot b$
-   $S = 10$
-   $f =$ € $300$
-   $p = 0.2$ and $0.3$
-   $q = 0.05$ and $0.10$
-   $r \leq 20$ (so there is an upper bound on the total number of reservations).

Make graphs of the different combinations. In each case, estimate the booking limit ten hours before flight time from your graphs. Discuss whether your graphs confirm the claim in (b) that $r \mapsto V^*_n(r)$ is quasiconcave.

What conjectures do the graphs suggest about the optimal reservation policy and/or maximum expected reward and their variation with the various data elements? You will lose points on your conjectures only if your graphs are inconsistent with or do not support your conjectures, or if you don’t make enough interesting conjectures. The idea here is to brainstorm intelligently.

## Solutions

### c) Solving the Problem

```{python}
# Load packages
from scipy.stats import binom
import pandas as pd
import plotly.express as px
import plotly.graph_objects as go
```

```{python}
# Functions

def solve_mdp(T, f, S, p, q, r_max):

    V_opt = {}
    policy_opt = {}

    for n in range(T+1):

        V_opt[n] = {}
        policy_opt[n] = {}

        if n==0:
            for r in  range(T+1):
                if r <= S:
                    V_opt[n][r] = f*r
                else:
                    V_opt[n][r] = f*S - f*(r - S)

        else:
            for r in range(T+1 - n):
            
                cancellations = {
                    c: binom.pmf(k=c, n=r, p=q) for c in range(r)
                }
                V_accept = sum([
                    prob_c*(p*V_opt[n-1][r+1-c] + (1-p)*V_opt[n-1][r-c])
                    for c, prob_c in cancellations.items()
                ])
                V_reject = sum([
                    prob_c*V_opt[n-1][r-c]
                    for c, prob_c in cancellations.items()
                ])

                if r >= r_max:
                    policy_opt[n][r] = "reject"
                    V_opt[n][r] = V_reject
                else:
                    if V_accept >= V_reject:
                        policy_opt[n][r] = "accept"
                        V_opt[n][r] = V_accept
                    else:
                        policy_opt[n][r] = "reject"
                        V_opt[n][r] = V_reject
    
    return policy_opt, V_opt

def print_policy(policy_opt, V_opt):
    for n, policy_n in policy_opt.items():
        print(f"Epochs before flight: {n}")
        for r in policy_n:
            print(f"When number of bookings is {r} then policy: {policy_n[r]}, with value {V_opt[n][r]:.2f}")

def plot_policy(policy_opt, V_opt, n, title):
    data_dict = {'r': policy_opt[n].keys(), 'policy': policy_opt[n].values(), 'V_star': V_opt[n].values()}
    data = pd.DataFrame(data_dict)
    fig = px.line(data, x = 'r', y = 'V_star', color='policy', title = title, markers=True)
    fig.show()

def plot_policies(T, f, S, r_max, probs=[(0.2, 0.05), (0.2, 0.1), (0.3, 0.05), (0.3, 0.1)], n=10):
    fig = go.Figure()
    
    # Get a list of colors to use for different (p, q) pairs
    color_sequence = px.colors.qualitative.Plotly  # Default Plotly color sequence
    probs_colors = {}  # Dictionary to map each (p, q) to a specific color

    for idx, (p, q) in enumerate(probs):
        policy_opt, V_opt = solve_mdp(T, f, S, p, q, r_max)
        data_dict = {
            'r': list(policy_opt[10].keys()),
            'policy': list(policy_opt[10].values()),
            'V_star': list(V_opt[10].values())
        }
        data = pd.DataFrame(data_dict)
        data = data.sort_values('r')

        # Assign a consistent color to this (p, q) pair
        color = color_sequence[idx % len(color_sequence)]
        probs_colors[(p, q)] = color

        # Identify segments where policy is the same
        segments = []
        current_policy = None
        current_segment = {'r': [], 'V_star': [], 'policy': None}
        for index, row in data.iterrows():
            policy = row['policy']
            if current_policy is None or policy != current_policy:
                if current_segment['r']:
                    segments.append(current_segment)
                current_policy = policy
                current_segment = {'r': [], 'V_star': [], 'policy': policy}
            current_segment['r'].append(row['r'])
            current_segment['V_star'].append(row['V_star'])
        segments.append(current_segment)  # Append the last segment

        # Plot each segment with appropriate line style and consistent color
        segment_count = 0
        for segment in segments:
            line_dash = 'solid' if segment['policy'] == 'accept' else 'dot'
            showlegend = segment_count == 0  # Show legend only for the first segment
            segment_count += 1
            fig.add_trace(go.Scatter(
                x=segment['r'],
                y=segment['V_star'],
                mode='lines+markers',
                name=f'p={p}, q={q}',
                text = segment['policy'],
                legendgroup=f'p={p}, q={q}',
                showlegend=showlegend,
                line=dict(dash=line_dash, color=color)
            ))

    # Edit the layout
    
    fig.update_layout(
        title=f"Optimal values and policies {n} epochs before flight",
        xaxis_title='Reservations (r)',
        yaxis_title='Optimal value (V*)',
    )
                                            
    fig.show()
```

#### Case

```{python}
T = 30
f = 300
S = 10
p_cases = [0.2, 0.3]
q_cases = [0.05, 0.1]
r_max = 22
```

##### Results

```{python}
probs = [(0.2, 0.05), (0.2, 0.1), (0.3, 0.05), (0.3, 0.1)]
n=10
plot_policies(T, f, S, r_max, probs, n)
```

#### Conjectures

1. The booking limit $b_n$ depends only on q and not on p.
2. The booking limit $b_n$ increases with q.
3. The optimal value $V^*_n(r)$ decreases with q and increases with p.

#### Cases

```{python}
p = p_cases[0]
q = q_cases[0]
n = 10
title = f"Optimal values and policies with p={p}, q={q} and {n} epochs before flight"
policy_opt, V_opt = solve_mdp(T, f, S, p, q, r_max)
plot_policy(policy_opt, V_opt, n, title)
print_policy(policy_opt, V_opt)
```

```{python}
p = p_cases[0]
q = q_cases[1]
n = 10
title = f"Optimal values and policies with p={p}, q={q} and {n} epochs before flight"
policy_opt, V_opt = solve_mdp(T, f, S, p, q, r_max)
plot_policy(policy_opt, V_opt, n, title)
print_policy(policy_opt, V_opt)
```

```{python}
p = p_cases[1]
q = q_cases[0]
n = 10
title = f"Optimal values and policies with p={p}, q={q} and {n} epochs before flight"
policy_opt, V_opt = solve_mdp(T, f, S, p, q, r_max)
plot_policy(policy_opt, V_opt, n, title)
print_policy(policy_opt, V_opt)
```

```{python}
p = p_cases[1]
q = q_cases[1]
n = 10
title = f"Optimal values and policies with p={p}, q={q} and {n} epochs before flight"
policy_opt, V_opt = solve_mdp(T, f, S, p, q, r_max)
plot_policy(policy_opt, V_opt, n, title)
print_policy(policy_opt, V_opt)
```

